var e=Object.defineProperty,t=Object.defineProperties,s=Object.getOwnPropertyDescriptors,a=Object.getOwnPropertySymbols,i=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,o=(t,s,a)=>s in t?e(t,s,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[s]=a,l=(e,t)=>{for(var s in t||(t={}))i.call(t,s)&&o(e,s,t[s]);if(a)for(var s of a(t))d.call(t,s)&&o(e,s,t[s]);return e},n=(e,a)=>t(e,s(a));import{y as r,h as c,z as u,A as m,T as h,l as p,q as v,r as g,w,t as D,v as T,p as y,F as f}from"./firebase-DbUGxvwD.js";import{d as E}from"./index-DEgoYGZl.js";const A={createSession:async e=>{var t;try{const s={meetLink:e.meetLink,topic:e.title||e.topic||"Untitled Session",title:e.title||e.topic||"Untitled Session",description:e.description||"",date:h.fromDate(new Date(e.scheduledTime||e.date)),scheduledTime:h.fromDate(new Date(e.scheduledTime||e.date)),duration:e.duration||60,category:e.category||"lecture",visibility:e.visibility||"private",maxParticipants:e.maxParticipants||50,courseId:e.courseId||"general",enableRecording:null==(t=e.enableRecording)||t,isRecorded:!1,recordingUrl:"",status:"scheduled",recordingStatus:e.enableRecording?"not_started":"disabled",isPublished:"public"===e.visibility,instructorId:e.instructorId||e.createdBy,instructorEmail:e.instructorEmail,instructorName:e.instructorName,createdBy:e.instructorId||e.createdBy,createdAt:u(),updatedAt:u(),sessionEndTime:e.sessionEndTime?h.fromDate(new Date(e.sessionEndTime)):h.fromDate(new Date((e.scheduledTime?new Date(e.scheduledTime).getTime():Date.now())+6e4*(e.duration||60))),participants:[],participantCount:0,participantEmails:e.participantEmails||[],courseName:e.courseName||""};Object.keys(s).forEach(e=>{void 0===s[e]&&delete s[e]});const a=await f(g(E,"sessions"),s);return l({success:!0,id:a.id},s)}catch(s){throw new Error(`Failed to create session: ${s.message}`)}},createSessionRecording:async e=>{try{if(!e.sessionId)throw new Error("sessionId is required for recording");const t=n(l({},e),{enableRecording:!0,recordingStatus:"not_started"});return await A.createSession(t)}catch(t){throw new Error(`Failed to create session recording: ${t.message}`)}},getAllSessions:async(e={})=>{try{const{limit:t=50,status:s="all",isRecorded:a="all",dateRange:i="all",instructorId:d=null}=e;let o=v(g(E,"sessions"),D("scheduledTime","desc"));"all"!==s&&(o=v(o,w("status","==",s))),"all"!==a&&(o=v(o,w("isRecorded","==","recorded"===a))),d&&(o=v(o,w("instructorId","==",d))),"upcoming"===i?o=v(o,w("scheduledTime",">=",h.now())):"past"===i&&(o=v(o,w("scheduledTime","<",h.now()))),t&&t>0&&(o=v(o,T(t)));const r=await y(o),c=[];return r.forEach(e=>{var t,s,a,i,d,o,r,u,m,h;const p=e.data();c.push(n(l({id:e.id},p),{date:null==(s=null==(t=p.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(i=null==(a=p.scheduledTime)?void 0:a.toDate)?void 0:i.call(a),sessionEndTime:null==(o=null==(d=p.sessionEndTime)?void 0:d.toDate)?void 0:o.call(d),createdAt:null==(u=null==(r=p.createdAt)?void 0:r.toDate)?void 0:u.call(r),updatedAt:null==(h=null==(m=p.updatedAt)?void 0:m.toDate)?void 0:h.call(m)}))}),c}catch(t){throw new Error(`Failed to fetch sessions: ${t.message}`)}},getPublicSessions:async(e={})=>{try{const{limit:t=50,status:s="scheduled",dateRange:a="upcoming",instructorId:i=null}=e;let d=v(g(E,"sessions"),w("isPublished","==",!0),w("status","==",s),D("scheduledTime","asc"));"upcoming"===a?d=v(d,w("scheduledTime",">=",h.now())):"past"===a&&(d=v(d,w("scheduledTime","<",h.now()))),i&&(d=v(d,w("instructorId","==",i))),t&&t>0&&(d=v(d,T(t)));const o=await y(d),r=[];return o.forEach(e=>{var t,s,a,i,d,o,c,u,m,h;const p=e.data();r.push(n(l({id:e.id},p),{date:null==(s=null==(t=p.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(i=null==(a=p.scheduledTime)?void 0:a.toDate)?void 0:i.call(a),sessionEndTime:null==(o=null==(d=p.sessionEndTime)?void 0:d.toDate)?void 0:o.call(d),createdAt:null==(u=null==(c=p.createdAt)?void 0:c.toDate)?void 0:u.call(c),updatedAt:null==(h=null==(m=p.updatedAt)?void 0:m.toDate)?void 0:h.call(m)}))}),r}catch(t){throw new Error(`Failed to fetch public sessions: ${t.message}`)}},getTeacherSessionsForStudents:async(e={})=>{try{const{limit:t=20,daysAhead:s=30}=e,a=new Date,i=new Date;i.setDate(i.getDate()+s);const d=v(g(E,"sessions"),w("isPublished","==",!0),w("status","==","scheduled"),w("scheduledTime",">=",h.fromDate(a)),w("scheduledTime","<=",h.fromDate(i)),D("scheduledTime","asc"),T(t)),o=await y(d),r=[];return o.forEach(e=>{var t,s,a,i,d,o,c,u,m,h;const p=e.data();r.push(n(l({id:e.id},p),{date:null==(s=null==(t=p.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(i=null==(a=p.scheduledTime)?void 0:a.toDate)?void 0:i.call(a),sessionEndTime:null==(o=null==(d=p.sessionEndTime)?void 0:d.toDate)?void 0:o.call(d),createdAt:null==(u=null==(c=p.createdAt)?void 0:c.toDate)?void 0:u.call(c),updatedAt:null==(h=null==(m=p.updatedAt)?void 0:m.toDate)?void 0:h.call(m)}))}),r}catch(t){throw new Error(`Failed to fetch teacher sessions for students: ${t.message}`)}},getCourseSessions:async(e,t={})=>{try{const{limit:s=50}=t;let a=v(g(E,"sessions"),w("courseId","==",e),D("scheduledTime","desc"));s&&s>0&&(a=v(a,T(s)));const i=await y(a),d=[];return i.forEach(e=>{var t,s,a,i,o,r,c,u;const m=e.data();d.push(n(l({id:e.id},m),{date:null==(s=null==(t=m.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(i=null==(a=m.scheduledTime)?void 0:a.toDate)?void 0:i.call(a),createdAt:null==(r=null==(o=m.createdAt)?void 0:o.toDate)?void 0:r.call(o),updatedAt:null==(u=null==(c=m.updatedAt)?void 0:c.toDate)?void 0:u.call(c)}))}),d}catch(s){throw new Error(`Failed to fetch course sessions: ${s.message}`)}},getUpcomingSessions:async(e=20)=>{try{const t=v(g(E,"sessions"),w("scheduledTime",">=",h.now()),w("status","in",["scheduled","live"]),D("scheduledTime","asc"),T(e)),s=await y(t),a=[];return s.forEach(e=>{var t,s,i,d,o,r,c,u;const m=e.data();a.push(n(l({id:e.id},m),{date:null==(s=null==(t=m.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(d=null==(i=m.scheduledTime)?void 0:i.toDate)?void 0:d.call(i),createdAt:null==(r=null==(o=m.createdAt)?void 0:o.toDate)?void 0:r.call(o),updatedAt:null==(u=null==(c=m.updatedAt)?void 0:c.toDate)?void 0:u.call(c)}))}),a}catch(t){throw new Error(`Failed to fetch upcoming sessions: ${t.message}`)}},getInstructorUpcomingSessions:async(e,t={})=>{try{const{limit:s=10,daysAhead:a=7}=t,i=new Date,d=new Date;d.setDate(d.getDate()+a);let o=v(g(E,"sessions"),w("instructorId","==",e),w("scheduledTime",">=",h.fromDate(i)),w("scheduledTime","<=",h.fromDate(d)),w("status","in",["scheduled","live"]),D("scheduledTime","asc"));s&&s>0&&(o=v(o,T(s)));const r=await y(o),c=[];return r.forEach(e=>{var t,s,a,i,d,o,r,u;const m=e.data();c.push(n(l({id:e.id},m),{date:null==(s=null==(t=m.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(i=null==(a=m.scheduledTime)?void 0:a.toDate)?void 0:i.call(a),createdAt:null==(o=null==(d=m.createdAt)?void 0:d.toDate)?void 0:o.call(d),updatedAt:null==(u=null==(r=m.updatedAt)?void 0:r.toDate)?void 0:u.call(r)}))}),c}catch(s){throw new Error(`Failed to fetch instructor upcoming sessions: ${s.message}`)}},getInstructorSessions:async(e,t={})=>{try{const{limit:s=50,status:a="all"}=t;let i=v(g(E,"sessions"),w("instructorId","==",e),D("scheduledTime","desc"));"all"!==a&&(i=v(i,w("status","==",a))),s&&s>0&&(i=v(i,T(s)));const d=await y(i),o=[];return d.forEach(e=>{var t,s,a,i,d,r,c,u;const m=e.data();o.push(n(l({id:e.id},m),{date:null==(s=null==(t=m.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(i=null==(a=m.scheduledTime)?void 0:a.toDate)?void 0:i.call(a),createdAt:null==(r=null==(d=m.createdAt)?void 0:d.toDate)?void 0:r.call(d),updatedAt:null==(u=null==(c=m.updatedAt)?void 0:c.toDate)?void 0:u.call(c)}))}),o}catch(s){throw new Error(`Failed to fetch instructor sessions: ${s.message}`)}},getRecordedSessions:async(e=20)=>{try{const t=v(g(E,"sessions"),w("isRecorded","==",!0),D("scheduledTime","desc"),T(e)),s=await y(t),a=[];return s.forEach(e=>{var t,s,i,d,o,r,c,u;const m=e.data();a.push(n(l({id:e.id},m),{date:null==(s=null==(t=m.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(d=null==(i=m.scheduledTime)?void 0:i.toDate)?void 0:d.call(i),createdAt:null==(r=null==(o=m.createdAt)?void 0:o.toDate)?void 0:r.call(o),updatedAt:null==(u=null==(c=m.updatedAt)?void 0:c.toDate)?void 0:u.call(c)}))}),a}catch(t){throw new Error(`Failed to fetch recorded sessions: ${t.message}`)}},getSessionById:async e=>{var t,s,a,i,d,o,r,u,m,h;try{const v=await p(c(E,"sessions",e));if(!v.exists())return null;const g=v.data();return n(l({id:v.id},g),{date:null==(s=null==(t=g.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(i=null==(a=g.scheduledTime)?void 0:a.toDate)?void 0:i.call(a),sessionEndTime:null==(o=null==(d=g.sessionEndTime)?void 0:d.toDate)?void 0:o.call(d),createdAt:null==(u=null==(r=g.createdAt)?void 0:r.toDate)?void 0:u.call(r),updatedAt:null==(h=null==(m=g.updatedAt)?void 0:m.toDate)?void 0:h.call(m)})}catch(v){throw new Error(`Failed to fetch session: ${v.message}`)}},updateSession:async(e,t)=>{try{const s=["meetLink","topic","title","description","scheduledTime","date","status","courseId","courseName","duration","category","visibility","maxParticipants","enableRecording","recordingStatus","isPublished","sessionEndTime"],a={};Object.keys(t).forEach(e=>{s.includes(e)&&(a[e]=t[e])});const i=n(l({},a),{updatedAt:u()});return t.scheduledTime&&t.scheduledTime instanceof Date&&(i.scheduledTime=h.fromDate(t.scheduledTime)),t.date&&t.date instanceof Date&&(i.date=h.fromDate(t.date)),t.sessionEndTime&&t.sessionEndTime instanceof Date&&(i.sessionEndTime=h.fromDate(t.sessionEndTime)),await m(c(E,"sessions",e),i),{success:!0,sessionId:e,updates:a}}catch(s){throw new Error(`Failed to update session: ${s.message}`)}},markAsRecorded:async(e,t)=>{try{const s={isRecorded:!0,recordingUrl:t,recordingStatus:"completed",status:"completed",updatedAt:u()};return await m(c(E,"sessions",e),s),{success:!0,sessionId:e,recordingUrl:t}}catch(s){throw new Error(`Failed to mark session as recorded: ${s.message}`)}},removeRecording:async e=>{try{const t={isRecorded:!1,recordingUrl:"",recordingStatus:"disabled",updatedAt:u()};return await m(c(E,"sessions",e),t),{success:!0,sessionId:e}}catch(t){throw new Error(`Failed to remove recording: ${t.message}`)}},updateSessionStatus:async(e,t)=>{try{const s=["scheduled","live","completed","cancelled"];if(!s.includes(t))throw new Error(`Invalid status: ${t}. Must be one of: ${s.join(", ")}`);return await m(c(E,"sessions",e),{status:t,updatedAt:u()}),{success:!0,sessionId:e,status:t}}catch(s){throw new Error(`Failed to update session status: ${s.message}`)}},addParticipant:async(e,t,s={})=>{try{const a=await A.getSessionById(e);if(!a)throw new Error("Session not found");const i=l({id:t,joinedAt:u()},s),d=[...a.participants||[],i],o=[...new Set([...a.participantEmails||[],s.email].filter(Boolean))];return await m(c(E,"sessions",e),{participants:d,participantCount:d.length,participantEmails:o,updatedAt:u()}),{success:!0,sessionId:e,participantId:t,participantCount:d.length}}catch(a){throw new Error(`Failed to add participant: ${a.message}`)}},deleteSession:async e=>{try{const t=await A.getSessionById(e);if(!t)throw new Error("Session not found");return t.isRecorded,await r(c(E,"sessions",e)),{success:!0,sessionId:e,hadRecording:t.isRecorded}}catch(t){throw new Error(`Failed to delete session: ${t.message}`)}},getSessionStats:async(e=null)=>{try{const t=e?{instructorId:e}:{},[s,a,i]=await Promise.all([A.getAllSessions(n(l({},t),{limit:1e3})),A.getUpcomingSessions(1e3),A.getRecordedSessions(1e3)]),d=e?s.filter(t=>t.instructorId===e):s,o=e?a.filter(t=>t.instructorId===e):a,r=e?i.filter(t=>t.instructorId===e):i;return{total:d.length,upcoming:o.length,recorded:r.length,live:d.filter(e=>"live"===e.status).length,completed:d.filter(e=>"completed"===e.status).length,cancelled:d.filter(e=>"cancelled"===e.status).length,averageParticipants:d.length>0?d.reduce((e,t)=>e+(t.participantCount||0),0)/d.length:0,recentSessions:d.slice(0,5)}}catch(t){throw new Error(`Failed to fetch session statistics: ${t.message}`)}},getInstructorSessionStats:async e=>A.getSessionStats(e)};export{A as s};
