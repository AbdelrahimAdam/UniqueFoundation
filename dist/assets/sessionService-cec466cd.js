var e=Object.defineProperty,t=Object.defineProperties,s=Object.getOwnPropertyDescriptors,a=Object.getOwnPropertySymbols,i=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,o=(t,s,a)=>s in t?e(t,s,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[s]=a,n=(e,t)=>{for(var s in t||(t={}))i.call(t,s)&&o(e,s,t[s]);if(a)for(var s of a(t))d.call(t,s)&&o(e,s,t[s]);return e},l=(e,a)=>t(e,s(a));import{T as r,y as c,C as u,r as m,q as h,t as p,w as v,v as g,p as w,n as D,h as T,z as y,B as f}from"./firebase-a4f86f3d.js";import{d as E}from"./index-cde8ec3e.js";const A={createSession:async e=>{var t;try{const s={meetLink:e.meetLink,topic:e.title||e.topic||"Untitled Session",title:e.title||e.topic||"Untitled Session",description:e.description||"",date:r.fromDate(new Date(e.scheduledTime||e.date)),scheduledTime:r.fromDate(new Date(e.scheduledTime||e.date)),duration:e.duration||60,category:e.category||"lecture",visibility:e.visibility||"private",maxParticipants:e.maxParticipants||50,courseId:e.courseId||"general",enableRecording:null==(t=e.enableRecording)||t,isRecorded:!1,recordingUrl:"",status:"scheduled",recordingStatus:e.enableRecording?"not_started":"disabled",isPublished:"public"===e.visibility,instructorId:e.instructorId||e.createdBy,instructorEmail:e.instructorEmail,instructorName:e.instructorName,createdBy:e.instructorId||e.createdBy,createdAt:c(),updatedAt:c(),sessionEndTime:e.sessionEndTime?r.fromDate(new Date(e.sessionEndTime)):r.fromDate(new Date((e.scheduledTime?new Date(e.scheduledTime).getTime():Date.now())+6e4*(e.duration||60))),participants:[],participantCount:0,participantEmails:e.participantEmails||[],courseName:e.courseName||""};Object.keys(s).forEach(e=>{void 0===s[e]&&delete s[e]});const a=await u(m(E,"sessions"),s);return n({success:!0,id:a.id},s)}catch(s){throw new Error(`Failed to create session: ${s.message}`)}},createSessionRecording:async e=>{try{if(!e.sessionId)throw new Error("sessionId is required for recording");const t=l(n({},e),{enableRecording:!0,recordingStatus:"not_started"});return await A.createSession(t)}catch(t){throw new Error(`Failed to create session recording: ${t.message}`)}},getAllSessions:async(e={})=>{try{const{limit:t=50,status:s="all",isRecorded:a="all",dateRange:i="all",instructorId:d=null}=e;let o=h(m(E,"sessions"),p("scheduledTime","desc"));"all"!==s&&(o=h(o,v("status","==",s))),"all"!==a&&(o=h(o,v("isRecorded","==","recorded"===a))),d&&(o=h(o,v("instructorId","==",d))),"upcoming"===i?o=h(o,v("scheduledTime",">=",r.now())):"past"===i&&(o=h(o,v("scheduledTime","<",r.now()))),t&&t>0&&(o=h(o,g(t)));const c=await w(o),u=[];return c.forEach(e=>{var t,s,a,i,d,o,r,c,m,h;const p=e.data();u.push(l(n({id:e.id},p),{date:null==(s=null==(t=p.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(i=null==(a=p.scheduledTime)?void 0:a.toDate)?void 0:i.call(a),sessionEndTime:null==(o=null==(d=p.sessionEndTime)?void 0:d.toDate)?void 0:o.call(d),createdAt:null==(c=null==(r=p.createdAt)?void 0:r.toDate)?void 0:c.call(r),updatedAt:null==(h=null==(m=p.updatedAt)?void 0:m.toDate)?void 0:h.call(m)}))}),u}catch(t){throw new Error(`Failed to fetch sessions: ${t.message}`)}},getPublicSessions:async(e={})=>{try{const{limit:t=50,status:s="scheduled",dateRange:a="upcoming",instructorId:i=null}=e;let d=h(m(E,"sessions"),v("isPublished","==",!0),v("status","==",s),p("scheduledTime","asc"));"upcoming"===a?d=h(d,v("scheduledTime",">=",r.now())):"past"===a&&(d=h(d,v("scheduledTime","<",r.now()))),i&&(d=h(d,v("instructorId","==",i))),t&&t>0&&(d=h(d,g(t)));const o=await w(d),c=[];return o.forEach(e=>{var t,s,a,i,d,o,r,u,m,h;const p=e.data();c.push(l(n({id:e.id},p),{date:null==(s=null==(t=p.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(i=null==(a=p.scheduledTime)?void 0:a.toDate)?void 0:i.call(a),sessionEndTime:null==(o=null==(d=p.sessionEndTime)?void 0:d.toDate)?void 0:o.call(d),createdAt:null==(u=null==(r=p.createdAt)?void 0:r.toDate)?void 0:u.call(r),updatedAt:null==(h=null==(m=p.updatedAt)?void 0:m.toDate)?void 0:h.call(m)}))}),c}catch(t){throw new Error(`Failed to fetch public sessions: ${t.message}`)}},getTeacherSessionsForStudents:async(e={})=>{try{const{limit:t=20,daysAhead:s=30}=e,a=new Date,i=new Date;i.setDate(i.getDate()+s);const d=h(m(E,"sessions"),v("isPublished","==",!0),v("status","==","scheduled"),v("scheduledTime",">=",r.fromDate(a)),v("scheduledTime","<=",r.fromDate(i)),p("scheduledTime","asc"),g(t)),o=await w(d),c=[];return o.forEach(e=>{var t,s,a,i,d,o,r,u,m,h;const p=e.data();c.push(l(n({id:e.id},p),{date:null==(s=null==(t=p.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(i=null==(a=p.scheduledTime)?void 0:a.toDate)?void 0:i.call(a),sessionEndTime:null==(o=null==(d=p.sessionEndTime)?void 0:d.toDate)?void 0:o.call(d),createdAt:null==(u=null==(r=p.createdAt)?void 0:r.toDate)?void 0:u.call(r),updatedAt:null==(h=null==(m=p.updatedAt)?void 0:m.toDate)?void 0:h.call(m)}))}),c}catch(t){throw new Error(`Failed to fetch teacher sessions for students: ${t.message}`)}},getCourseSessions:async(e,t={})=>{try{const{limit:s=50}=t;let a=h(m(E,"sessions"),v("courseId","==",e),p("scheduledTime","desc"));s&&s>0&&(a=h(a,g(s)));const i=await w(a),d=[];return i.forEach(e=>{var t,s,a,i,o,r,c,u;const m=e.data();d.push(l(n({id:e.id},m),{date:null==(s=null==(t=m.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(i=null==(a=m.scheduledTime)?void 0:a.toDate)?void 0:i.call(a),createdAt:null==(r=null==(o=m.createdAt)?void 0:o.toDate)?void 0:r.call(o),updatedAt:null==(u=null==(c=m.updatedAt)?void 0:c.toDate)?void 0:u.call(c)}))}),d}catch(s){throw new Error(`Failed to fetch course sessions: ${s.message}`)}},getUpcomingSessions:async(e=20)=>{try{const t=h(m(E,"sessions"),v("scheduledTime",">=",r.now()),v("status","in",["scheduled","live"]),p("scheduledTime","asc"),g(e)),s=await w(t),a=[];return s.forEach(e=>{var t,s,i,d,o,r,c,u;const m=e.data();a.push(l(n({id:e.id},m),{date:null==(s=null==(t=m.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(d=null==(i=m.scheduledTime)?void 0:i.toDate)?void 0:d.call(i),createdAt:null==(r=null==(o=m.createdAt)?void 0:o.toDate)?void 0:r.call(o),updatedAt:null==(u=null==(c=m.updatedAt)?void 0:c.toDate)?void 0:u.call(c)}))}),a}catch(t){throw new Error(`Failed to fetch upcoming sessions: ${t.message}`)}},getInstructorUpcomingSessions:async(e,t={})=>{try{const{limit:s=10,daysAhead:a=7}=t,i=new Date,d=new Date;d.setDate(d.getDate()+a);let o=h(m(E,"sessions"),v("instructorId","==",e),v("scheduledTime",">=",r.fromDate(i)),v("scheduledTime","<=",r.fromDate(d)),v("status","in",["scheduled","live"]),p("scheduledTime","asc"));s&&s>0&&(o=h(o,g(s)));const c=await w(o),u=[];return c.forEach(e=>{var t,s,a,i,d,o,r,c;const m=e.data();u.push(l(n({id:e.id},m),{date:null==(s=null==(t=m.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(i=null==(a=m.scheduledTime)?void 0:a.toDate)?void 0:i.call(a),createdAt:null==(o=null==(d=m.createdAt)?void 0:d.toDate)?void 0:o.call(d),updatedAt:null==(c=null==(r=m.updatedAt)?void 0:r.toDate)?void 0:c.call(r)}))}),u}catch(s){throw new Error(`Failed to fetch instructor upcoming sessions: ${s.message}`)}},getInstructorSessions:async(e,t={})=>{try{const{limit:s=50,status:a="all"}=t;let i=h(m(E,"sessions"),v("instructorId","==",e),p("scheduledTime","desc"));"all"!==a&&(i=h(i,v("status","==",a))),s&&s>0&&(i=h(i,g(s)));const d=await w(i),o=[];return d.forEach(e=>{var t,s,a,i,d,r,c,u;const m=e.data();o.push(l(n({id:e.id},m),{date:null==(s=null==(t=m.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(i=null==(a=m.scheduledTime)?void 0:a.toDate)?void 0:i.call(a),createdAt:null==(r=null==(d=m.createdAt)?void 0:d.toDate)?void 0:r.call(d),updatedAt:null==(u=null==(c=m.updatedAt)?void 0:c.toDate)?void 0:u.call(c)}))}),o}catch(s){throw new Error(`Failed to fetch instructor sessions: ${s.message}`)}},getRecordedSessions:async(e=20)=>{try{const t=h(m(E,"sessions"),v("isRecorded","==",!0),p("scheduledTime","desc"),g(e)),s=await w(t),a=[];return s.forEach(e=>{var t,s,i,d,o,r,c,u;const m=e.data();a.push(l(n({id:e.id},m),{date:null==(s=null==(t=m.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(d=null==(i=m.scheduledTime)?void 0:i.toDate)?void 0:d.call(i),createdAt:null==(r=null==(o=m.createdAt)?void 0:o.toDate)?void 0:r.call(o),updatedAt:null==(u=null==(c=m.updatedAt)?void 0:c.toDate)?void 0:u.call(c)}))}),a}catch(t){throw new Error(`Failed to fetch recorded sessions: ${t.message}`)}},getSessionById:async e=>{var t,s,a,i,d,o,r,c,u,m;try{const h=await D(T(E,"sessions",e));if(!h.exists())return null;const p=h.data();return l(n({id:h.id},p),{date:null==(s=null==(t=p.date)?void 0:t.toDate)?void 0:s.call(t),scheduledTime:null==(i=null==(a=p.scheduledTime)?void 0:a.toDate)?void 0:i.call(a),sessionEndTime:null==(o=null==(d=p.sessionEndTime)?void 0:d.toDate)?void 0:o.call(d),createdAt:null==(c=null==(r=p.createdAt)?void 0:r.toDate)?void 0:c.call(r),updatedAt:null==(m=null==(u=p.updatedAt)?void 0:u.toDate)?void 0:m.call(u)})}catch(h){throw new Error(`Failed to fetch session: ${h.message}`)}},updateSession:async(e,t)=>{try{const s=["meetLink","topic","title","description","scheduledTime","date","status","courseId","courseName","duration","category","visibility","maxParticipants","enableRecording","recordingStatus","isPublished","sessionEndTime"],a={};Object.keys(t).forEach(e=>{s.includes(e)&&(a[e]=t[e])});const i=l(n({},a),{updatedAt:c()});return t.scheduledTime&&t.scheduledTime instanceof Date&&(i.scheduledTime=r.fromDate(t.scheduledTime)),t.date&&t.date instanceof Date&&(i.date=r.fromDate(t.date)),t.sessionEndTime&&t.sessionEndTime instanceof Date&&(i.sessionEndTime=r.fromDate(t.sessionEndTime)),await y(T(E,"sessions",e),i),{success:!0,sessionId:e,updates:a}}catch(s){throw new Error(`Failed to update session: ${s.message}`)}},markAsRecorded:async(e,t)=>{try{const s={isRecorded:!0,recordingUrl:t,recordingStatus:"completed",status:"completed",updatedAt:c()};return await y(T(E,"sessions",e),s),{success:!0,sessionId:e,recordingUrl:t}}catch(s){throw new Error(`Failed to mark session as recorded: ${s.message}`)}},removeRecording:async e=>{try{const t={isRecorded:!1,recordingUrl:"",recordingStatus:"disabled",updatedAt:c()};return await y(T(E,"sessions",e),t),{success:!0,sessionId:e}}catch(t){throw new Error(`Failed to remove recording: ${t.message}`)}},updateSessionStatus:async(e,t)=>{try{const s=["scheduled","live","completed","cancelled"];if(!s.includes(t))throw new Error(`Invalid status: ${t}. Must be one of: ${s.join(", ")}`);return await y(T(E,"sessions",e),{status:t,updatedAt:c()}),{success:!0,sessionId:e,status:t}}catch(s){throw new Error(`Failed to update session status: ${s.message}`)}},addParticipant:async(e,t,s={})=>{try{const a=await A.getSessionById(e);if(!a)throw new Error("Session not found");const i=n({id:t,joinedAt:c()},s),d=[...a.participants||[],i],o=[...new Set([...a.participantEmails||[],s.email].filter(Boolean))];return await y(T(E,"sessions",e),{participants:d,participantCount:d.length,participantEmails:o,updatedAt:c()}),{success:!0,sessionId:e,participantId:t,participantCount:d.length}}catch(a){throw new Error(`Failed to add participant: ${a.message}`)}},deleteSession:async e=>{try{const t=await A.getSessionById(e);if(!t)throw new Error("Session not found");return t.isRecorded,await f(T(E,"sessions",e)),{success:!0,sessionId:e,hadRecording:t.isRecorded}}catch(t){throw new Error(`Failed to delete session: ${t.message}`)}},getSessionStats:async(e=null)=>{try{const t=e?{instructorId:e}:{},[s,a,i]=await Promise.all([A.getAllSessions(l(n({},t),{limit:1e3})),A.getUpcomingSessions(1e3),A.getRecordedSessions(1e3)]),d=e?s.filter(t=>t.instructorId===e):s,o=e?a.filter(t=>t.instructorId===e):a,r=e?i.filter(t=>t.instructorId===e):i;return{total:d.length,upcoming:o.length,recorded:r.length,live:d.filter(e=>"live"===e.status).length,completed:d.filter(e=>"completed"===e.status).length,cancelled:d.filter(e=>"cancelled"===e.status).length,averageParticipants:d.length>0?d.reduce((e,t)=>e+(t.participantCount||0),0)/d.length:0,recentSessions:d.slice(0,5)}}catch(t){throw new Error(`Failed to fetch session statistics: ${t.message}`)}},getInstructorSessionStats:async e=>A.getSessionStats(e)};export{A as s};
