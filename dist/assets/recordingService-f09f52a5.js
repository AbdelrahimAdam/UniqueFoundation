var e=Object.defineProperty,t=Object.defineProperties,r=Object.getOwnPropertyDescriptors,i=Object.getOwnPropertySymbols,a=Object.prototype.hasOwnProperty,l=Object.prototype.propertyIsEnumerable,d=(t,r,i)=>r in t?e(t,r,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[r]=i,o=(e,t)=>{for(var r in t||(t={}))a.call(t,r)&&d(e,r,t[r]);if(i)for(var r of i(t))l.call(t,r)&&d(e,r,t[r]);return e},s=(e,i)=>t(e,r(i));import{y as n,C as c,r as u,q as g,w as v,t as m,v as h,p,D as w,z as b,h as A,E as y,F as D,T as E,n as f,B as F,x as T,A as R}from"./firebase-a4f86f3d.js";import{d as S}from"./index-cde8ec3e.js";const I=()=>`sess_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,P=e=>{const t=o({},e);return Object.keys(t).forEach(e=>{void 0===t[e]&&delete t[e]}),t},k=e=>e?e instanceof Date?E.fromDate(e):"string"==typeof e?E.fromDate(new Date(e)):e:null,$={createRecording:async e=>{var t,r,i,a,l;try{if(!e.title||!e.instructorId||!e.instructorEmail)throw new Error("Recording title, instructor ID, and instructor email are required");const d=e.sessionId||I(),s={title:e.title.trim(),description:e.description||"",sessionId:d,meetLink:e.meetLink||"",instructorEmail:e.instructorEmail,driveFileId:e.driveFileId||"",driveFolder:"Meet Recordings",recordingUrl:e.recordingUrl||"",thumbnailUrl:e.thumbnailUrl||"",duration:e.duration||0,fileSize:e.fileSize||0,quality:e.quality||"720p",format:e.format||"mp4",scheduledTime:k(e.scheduledTime)||n(),sessionEndTime:k(e.sessionEndTime),actualStartTime:k(e.actualStartTime),actualEndTime:k(e.actualEndTime),status:e.status||"scheduled",recordingStatus:e.recordingStatus||"not_started",isPublished:null!=(t=e.isPublished)&&t,isFeatured:null!=(r=e.isFeatured)&&r,visibility:e.visibility||"private",createdBy:e.createdBy||e.instructorId,instructorId:e.instructorId,instructorName:e.instructorName||"",courseId:e.courseId||"general",participantEmails:e.participantEmails||[],attendeeCount:e.attendeeCount||0,maxParticipants:e.maxParticipants||50,views:0,likes:0,dislikes:0,averageRating:0,totalRatings:0,downloadCount:0,shareCount:0,category:e.category||"lecture",tags:e.tags||[],language:e.language||"en",level:e.level||"beginner",studentProgress:{},completedBy:[],createdAt:n(),updatedAt:n(),publishedAt:e.isPublished?n():null,recordingAvailableFrom:k(e.recordingAvailableFrom),recordingStartedAt:k(e.recordingStartedAt),recordingEndedAt:k(e.recordingEndedAt),processingStatus:"pending",processingProgress:0,errorMessage:null,slug:e.slug||e.title.toLowerCase().replace(/[^a-z0-9]+/g,"-"),metaTitle:e.metaTitle||e.title,metaDescription:e.metaDescription||(null==(i=e.description)?void 0:i.substring(0,160))||"",allowedUsers:e.allowedUsers||[],accessCode:e.accessCode||null,requiresApproval:null!=(a=e.requiresApproval)&&a,enableRecording:null==(l=e.enableRecording)||l},g=P(s),v=await c(u(S,"recordings"),g);return o({success:!0,id:v.id},g)}catch(d){throw new Error(`Failed to create recording: ${d.message}`)}},getStudentRecordings:async(e,t={})=>{try{const{limit:r=50,category:i="all",instructorId:a=null,sortBy:l="createdAt",sortOrder:d="desc"}=t;let n=g(u(S,"recordings"),v("isPublished","==",!0),v("recordingStatus","==","available"),m(l,d));i&&"all"!==i&&(n=g(n,v("category","==",i))),a&&(n=g(n,v("instructorId","==",a))),r&&r>0&&(n=g(n,h(r)));const c=await p(n),w=[],b=g(u(S,"enrollments"),v("studentId","==",e)),A=(await p(b)).docs.map(e=>e.data().courseId);return c.forEach(t=>{var r,i,a,l,d,n,c,u,g,v,m,h;const p=t.data(),b=p.courseId;if(!0===p.isPublished&&"available"===p.recordingStatus||A.includes(b)||"public"===p.visibility||"unlisted"===p.visibility){const y=e&&(null==(i=null==(r=p.studentProgress)?void 0:r[e])?void 0:i.watched)||!1,D=e&&(null==(l=null==(a=p.studentProgress)?void 0:a[e])?void 0:l.progress)||0;w.push(s(o({id:t.id},p),{watched:y,progress:D,createdAt:null==(n=null==(d=p.createdAt)?void 0:d.toDate)?void 0:n.call(d),updatedAt:null==(u=null==(c=p.updatedAt)?void 0:c.toDate)?void 0:u.call(c),publishedAt:null==(v=null==(g=p.publishedAt)?void 0:g.toDate)?void 0:v.call(g),recordingAvailableFrom:null==(h=null==(m=p.recordingAvailableFrom)?void 0:m.toDate)?void 0:h.call(m),isEnrolled:A.includes(b)}))}}),w}catch(r){throw new Error(`Failed to fetch student recordings: ${r.message}`)}},getFeaturedRecordingsForStudents:async(e,t=10)=>{try{const r=g(u(S,"recordings"),v("isPublished","==",!0),v("isFeatured","==",!0),v("recordingStatus","==","available"),m("createdAt","desc"),t(t)),i=await p(r),a=[],l=g(u(S,"enrollments"),v("studentId","==",e)),d=(await p(l)).docs.map(e=>e.data().courseId);return i.forEach(t=>{var r,i,l,n,c,u,g,v,m,h,p,w;const b=t.data(),A=b.courseId;if("public"===b.visibility||"unlisted"===b.visibility||d.includes(A)){const y=e&&(null==(i=null==(r=b.studentProgress)?void 0:r[e])?void 0:i.watched)||!1;a.push(s(o({id:t.id},b),{watched:y,progress:(null==(n=null==(l=b.studentProgress)?void 0:l[e])?void 0:n.progress)||0,createdAt:null==(u=null==(c=b.createdAt)?void 0:c.toDate)?void 0:u.call(c),updatedAt:null==(v=null==(g=b.updatedAt)?void 0:g.toDate)?void 0:v.call(g),publishedAt:null==(h=null==(m=b.publishedAt)?void 0:m.toDate)?void 0:h.call(m),recordingAvailableFrom:null==(w=null==(p=b.recordingAvailableFrom)?void 0:p.toDate)?void 0:w.call(p),isEnrolled:d.includes(A)}))}}),a}catch(r){throw new Error(`Failed to fetch featured recordings: ${r.message}`)}},updateStudentProgress:async(e,t,r)=>{try{const i={[`studentProgress.${t}`]:o({progress:r.progress||0,watched:r.watched||!1,lastWatched:n(),completedAt:r.progress>=95?n():null},r),updatedAt:n()};if(r.progress>=95){const r=await $.getRecordingById(e);(r.completedBy||[]).includes(t)||(i.completedBy=w(t))}return await b(A(S,"recordings",e),i),{success:!0,recordingId:e,studentId:t,progress:r.progress}}catch(i){throw new Error(`Failed to update student progress: ${i.message}`)}},incrementRecordingViews:async e=>{try{const t=A(S,"recordings",e);return await b(t,{views:y(1),updatedAt:n()}),!0}catch(t){throw new Error(`Failed to increment views: ${t.message}`)}},createSessionRecording:async e=>{try{const t={sessionId:e.sessionId||I(),title:e.title,description:e.description,meetLink:e.meetLink,instructorId:e.instructorId,instructorEmail:e.instructorEmail,instructorName:e.instructorName,scheduledTime:e.scheduledTime,sessionEndTime:e.sessionEndTime,duration:e.duration,category:e.category,visibility:e.visibility,courseId:e.courseId,maxParticipants:e.maxParticipants,enableRecording:e.enableRecording,status:"scheduled",recordingStatus:e.enableRecording?"not_started":"disabled",isPublished:"public"===e.visibility,createdBy:e.createdBy};return await $.createRecording(t)}catch(t){throw new Error(`Failed to create session recording: ${t.message}`)}},createRecordingFromMeetSession:async e=>{try{const t={title:e.title,description:e.description,meetLink:e.meetLink,instructorId:e.instructorId,instructorEmail:e.instructorEmail,instructorName:e.instructorName,scheduledTime:e.scheduledTime,sessionEndTime:e.sessionEndTime,participantEmails:e.participantEmails||[],courseId:e.courseId,status:"scheduled",recordingStatus:"not_started"};return await $.createRecording(t)}catch(t){throw new Error(`Failed to create recording from Meet session: ${t.message}`)}},startRecordingSession:async e=>{try{const t={status:"live",recordingStatus:"recording",actualStartTime:n(),updatedAt:n()};return await b(A(S,"recordings",e),t),{success:!0,recordingId:e,status:"live",recordingStatus:"recording"}}catch(t){throw new Error(`Failed to start recording session: ${t.message}`)}},endRecordingSession:async e=>{try{const t={status:"completed",recordingStatus:"processing",actualEndTime:n(),updatedAt:n()};return await b(A(S,"recordings",e),t),{success:!0,recordingId:e,status:"completed",recordingStatus:"processing"}}catch(t){throw new Error(`Failed to end recording session: ${t.message}`)}},updateWithDriveRecording:async(e,t)=>{try{if(!e||!t.recordingUrl)throw new Error("Recording ID and Google Drive URL are required");const r=$.extractDriveFileId(t.recordingUrl),i={recordingUrl:t.recordingUrl,driveFileId:r,recordingStatus:"available",status:"recorded",recordingAvailableFrom:n(),processingStatus:"completed",processingProgress:100,duration:t.duration||0,fileSize:t.fileSize||0,updatedAt:n()};return await b(A(S,"recordings",e),i),{success:!0,recordingId:e,driveFileId:r,recordingUrl:t.recordingUrl}}catch(r){throw new Error(`Failed to update recording with Drive data: ${r.message}`)}},addRecordingUrl:async(e,t)=>{try{if(!e||!t)throw new Error("Recording ID and URL are required");const r={recordingUrl:t,driveFileId:$.extractDriveFileId(t),recordingStatus:"available",status:"recorded",recordingAvailableFrom:n(),processingStatus:"completed",processingProgress:100,updatedAt:n()};return await b(A(S,"recordings",e),r),{success:!0,recordingId:e,recordingUrl:t}}catch(r){throw new Error(`Failed to add recording URL: ${r.message}`)}},extractDriveFileId:e=>{try{if(!e)return"";const t=/\/file\/d\/([a-zA-Z0-9_-]+)/,r=e.match(t);return r?r[1]:""}catch(t){return""}},generateDriveUrl:e=>e?`https://drive.google.com/file/d/${e}/view`:"",updateRecordingStatus:async(e,t,r={})=>{try{const i=o({status:t,updatedAt:n()},r);switch(t){case"live":i.actualStartTime=n(),i.recordingStatus="recording";break;case"completed":i.actualEndTime=n(),i.recordingStatus="processing";break;case"recorded":i.recordingStatus="available"}return await b(A(S,"recordings",e),i),{success:!0,recordingId:e,status:t,updatedAt:new Date}}catch(i){throw new Error(`Failed to update recording status: ${i.message}`)}},getSessionsForRecordingManagement:async e=>{try{const t=g(u(S,"recordings"),v("instructorId","==",e),v("status","in",["scheduled","live","completed"]),v("recordingStatus","in",["not_started","recording","processing"]),m("scheduledTime","desc")),r=await p(t);return r.docs.map(e=>{var t,r,i,a,l,d,n,c,u,g,v,m;const h=e.data();return s(o({id:e.id},h),{createdAt:null==(r=null==(t=h.createdAt)?void 0:t.toDate)?void 0:r.call(t),updatedAt:null==(a=null==(i=h.updatedAt)?void 0:i.toDate)?void 0:a.call(i),scheduledTime:null==(d=null==(l=h.scheduledTime)?void 0:l.toDate)?void 0:d.call(l),actualStartTime:null==(c=null==(n=h.actualStartTime)?void 0:n.toDate)?void 0:c.call(n),actualEndTime:null==(g=null==(u=h.actualEndTime)?void 0:u.toDate)?void 0:g.call(u),recordingAvailableFrom:null==(m=null==(v=h.recordingAvailableFrom)?void 0:v.toDate)?void 0:m.call(v)})})}catch(t){throw new Error(`Failed to fetch sessions for recording management: ${t.message}`)}},getRecordingsNeedingLinks:async(e=null)=>{try{let t=g(u(S,"recordings"),v("status","==","completed"),v("recordingStatus","in",["processing","not_started"]),v("recordingUrl","==",""),m("actualEndTime","desc"));e&&(t=g(t,v("instructorId","==",e)));const r=await p(t);return r.docs.map(e=>{var t,r,i,a,l,d,n,c;const u=e.data();return s(o({id:e.id},u),{createdAt:null==(r=null==(t=u.createdAt)?void 0:t.toDate)?void 0:r.call(t),updatedAt:null==(a=null==(i=u.updatedAt)?void 0:i.toDate)?void 0:a.call(i),scheduledTime:null==(d=null==(l=u.scheduledTime)?void 0:l.toDate)?void 0:d.call(l),actualEndTime:null==(c=null==(n=u.actualEndTime)?void 0:n.toDate)?void 0:c.call(n)})})}catch(t){throw new Error(`Failed to fetch recordings needing links: ${t.message}`)}},getInstructorMeetRecordings:async(e,t={})=>{try{const{status:r="all",recordingStatus:i="all",limit:a=50,cursor:l=null}=t;let d=g(u(S,"recordings"),v("instructorEmail","==",e),m("scheduledTime","desc"));"all"!==r&&(d=g(d,v("status","==",r))),"all"!==i&&(d=g(d,v("recordingStatus","==",i))),d=l?g(d,D(l),h(a)):g(d,h(a));const n=await p(d),c=n.docs.map(e=>{var t,r,i,a,l,d,n,c,u,g,v,m;const h=e.data();return s(o({id:e.id},h),{createdAt:null==(r=null==(t=h.createdAt)?void 0:t.toDate)?void 0:r.call(t),updatedAt:null==(a=null==(i=h.updatedAt)?void 0:i.toDate)?void 0:a.call(i),scheduledTime:null==(d=null==(l=h.scheduledTime)?void 0:l.toDate)?void 0:d.call(l),actualStartTime:null==(c=null==(n=h.actualStartTime)?void 0:n.toDate)?void 0:c.call(n),actualEndTime:null==(g=null==(u=h.actualEndTime)?void 0:u.toDate)?void 0:g.call(u),recordingAvailableFrom:null==(m=null==(v=h.recordingAvailableFrom)?void 0:v.toDate)?void 0:m.call(v)})});return{recordings:c,nextCursor:(n.docs.length>0?n.docs[n.docs.length-1]:null)||void 0}}catch(r){throw new Error(`Failed to fetch instructor Meet recordings: ${r.message}`)}},getUpcomingMeetSessions:async(e,t=7)=>{try{const r=new Date,i=new Date;i.setDate(i.getDate()+t);const a=g(u(S,"recordings"),v("instructorId","==",e),v("scheduledTime",">=",E.fromDate(r)),v("scheduledTime","<=",E.fromDate(i)),v("status","in",["scheduled","live"]),m("scheduledTime","asc")),l=await p(a);return l.docs.map(e=>{var t,r,i,a,l,d;const n=e.data();return s(o({id:e.id},n),{scheduledTime:null==(r=null==(t=n.scheduledTime)?void 0:t.toDate)?void 0:r.call(t),sessionEndTime:null==(a=null==(i=n.sessionEndTime)?void 0:i.toDate)?void 0:a.call(i),createdAt:null==(d=null==(l=n.createdAt)?void 0:l.toDate)?void 0:d.call(l)})})}catch(r){throw new Error(`Failed to fetch upcoming Meet sessions: ${r.message}`)}},getRecordingById:async e=>{var t,r,i,a,l,d,n,c,u,g,v,m,h,p,w,b,y,D,E,F;try{if(!e)throw new Error("Recording ID is required");const T=await f(A(S,"recordings",e));if(!T.exists())return null;const R=T.data(),I=s(o({id:T.id},R),{createdAt:null==(r=null==(t=R.createdAt)?void 0:t.toDate)?void 0:r.call(t),updatedAt:null==(a=null==(i=R.updatedAt)?void 0:i.toDate)?void 0:a.call(i),publishedAt:null==(d=null==(l=R.publishedAt)?void 0:l.toDate)?void 0:d.call(l),scheduledTime:null==(c=null==(n=R.scheduledTime)?void 0:n.toDate)?void 0:c.call(n),sessionEndTime:null==(g=null==(u=R.sessionEndTime)?void 0:u.toDate)?void 0:g.call(u),actualStartTime:null==(m=null==(v=R.actualStartTime)?void 0:v.toDate)?void 0:m.call(v),actualEndTime:null==(p=null==(h=R.actualEndTime)?void 0:h.toDate)?void 0:p.call(h),recordingAvailableFrom:null==(b=null==(w=R.recordingAvailableFrom)?void 0:w.toDate)?void 0:b.call(w),recordingStartedAt:null==(D=null==(y=R.recordingStartedAt)?void 0:y.toDate)?void 0:D.call(y),recordingEndedAt:null==(F=null==(E=R.recordingEndedAt)?void 0:E.toDate)?void 0:F.call(E)});return I.isLive=$.isRecordingLive(I),I}catch(T){throw new Error(`Failed to fetch recording: ${T.message}`)}},isRecordingLive:e=>{if(!e)return!1;const t=new Date,r=e.scheduledTime,i=e.sessionEndTime;return r&&i&&t>=r&&t<=i&&"live"===e.status},shouldStartSession:e=>{if(!e)return!1;const t=new Date,r=e.scheduledTime;return r&&t>=r&&"scheduled"===e.status},shouldEndSession:e=>{if(!e)return!1;const t=new Date,r=e.sessionEndTime;return r&&t>=r&&"live"===e.status},getAvailableRecordings:async(e={})=>{try{const{studentId:t,cursor:r=null,limit:i=12,category:a="all",instructorId:l=null,sortBy:d="recordingAvailableFrom",sortOrder:n="desc"}=e;let c=g(u(S,"recordings"),v("isPublished","==",!0),v("recordingStatus","==","available"),v("recordingUrl","!=",""),m(d,n));"all"!==a&&(c=g(c,v("category","==",a))),l&&(c=g(c,v("instructorId","==",l))),c=r?g(c,D(r),h(i)):g(c,h(i));const w=await p(c),b=w.docs.map(e=>{var r,i,a,l,d,n,c,u,g,v,m,h;const p=e.data(),w=t&&(null==(i=null==(r=p.studentProgress)?void 0:r[t])?void 0:i.watched)||!1,b=t&&(null==(l=null==(a=p.studentProgress)?void 0:a[t])?void 0:l.progress)||0;return s(o({id:e.id},p),{watched:w,progress:b,createdAt:null==(n=null==(d=p.createdAt)?void 0:d.toDate)?void 0:n.call(d),updatedAt:null==(u=null==(c=p.updatedAt)?void 0:c.toDate)?void 0:u.call(c),publishedAt:null==(v=null==(g=p.publishedAt)?void 0:g.toDate)?void 0:v.call(g),recordingAvailableFrom:null==(h=null==(m=p.recordingAvailableFrom)?void 0:m.toDate)?void 0:h.call(m)})});return{recordings:b,nextCursor:(w.docs.length>0?w.docs[w.docs.length-1]:null)||void 0}}catch(t){throw new Error(`Failed to fetch available recordings: ${t.message}`)}},getTeacherRecordings:async(e={})=>{try{const{teacherId:t,cursor:r=null,limit:i=12,status:a="all",isPublished:l="all",sortBy:d="createdAt",sortOrder:n="desc"}=e;if(!t)throw new Error("Teacher ID is required");let c=g(u(S,"recordings"),v("instructorId","==",t),m(d,n));"all"!==a&&(c=g(c,v("status","==",a))),"all"!==l&&(c=g(c,v("isPublished","==","published"===l))),c=r?g(c,D(r),h(i)):g(c,h(i));const w=await p(c),b=w.docs.map(e=>{var t,r,i,a,l,d,n,c,u,g,v,m;const h=e.data();return s(o({id:e.id},h),{createdAt:null==(r=null==(t=h.createdAt)?void 0:t.toDate)?void 0:r.call(t),updatedAt:null==(a=null==(i=h.updatedAt)?void 0:i.toDate)?void 0:a.call(i),publishedAt:null==(d=null==(l=h.publishedAt)?void 0:l.toDate)?void 0:d.call(l),scheduledTime:null==(c=null==(n=h.scheduledTime)?void 0:n.toDate)?void 0:c.call(n),actualStartTime:null==(g=null==(u=h.actualStartTime)?void 0:u.toDate)?void 0:g.call(u),actualEndTime:null==(m=null==(v=h.actualEndTime)?void 0:v.toDate)?void 0:m.call(v)})});return{recordings:b,nextCursor:(w.docs.length>0?w.docs[w.docs.length-1]:null)||void 0}}catch(t){throw new Error(`Failed to fetch teacher recordings: ${t.message}`)}},getAllRecordings:async(e={})=>{try{const{limit:t=50,status:r="all",isPublished:i="all",category:a="all",instructorId:l=null,sortBy:d="createdAt",sortOrder:n="desc",searchTerm:c=""}=e;let w=g(u(S,"recordings"),m(d,n));"all"!==r&&(w=g(w,v("status","==",r))),"all"!==i&&(w=g(w,v("isPublished","==","published"===i))),"all"!==a&&(w=g(w,v("category","==",a))),l&&(w=g(w,v("instructorId","==",l))),w=g(w,h(t));const b=(await p(w)).docs.map(e=>{var t,r,i,a,l,d,n,c,u,g,v,m;const h=e.data();return s(o({id:e.id},h),{createdAt:null==(r=null==(t=h.createdAt)?void 0:t.toDate)?void 0:r.call(t),updatedAt:null==(a=null==(i=h.updatedAt)?void 0:i.toDate)?void 0:a.call(i),publishedAt:null==(d=null==(l=h.publishedAt)?void 0:l.toDate)?void 0:d.call(l),scheduledTime:null==(c=null==(n=h.scheduledTime)?void 0:n.toDate)?void 0:c.call(n),actualStartTime:null==(g=null==(u=h.actualStartTime)?void 0:u.toDate)?void 0:g.call(u),actualEndTime:null==(m=null==(v=h.actualEndTime)?void 0:v.toDate)?void 0:m.call(v)})});let A=b;if(c){const e=c.toLowerCase();A=b.filter(t=>{var r,i,a,l;return(null==(r=t.title)?void 0:r.toLowerCase().includes(e))||(null==(i=t.description)?void 0:i.toLowerCase().includes(e))||(null==(a=t.tags)?void 0:a.some(t=>t.toLowerCase().includes(e)))||(null==(l=t.instructorName)?void 0:l.toLowerCase().includes(e))})}return A}catch(t){throw new Error(`Failed to fetch recordings: ${t.message}`)}},getFeaturedRecordings:async(e=10)=>{try{const t=g(u(S,"recordings"),v("isPublished","==",!0),v("isFeatured","==",!0),v("status","==","completed"),m("createdAt","desc"),e(e)),r=await p(t);return r.docs.map(e=>{var t,r,i,a,l,d,n,c;const u=e.data();return s(o({id:e.id},u),{createdAt:null==(r=null==(t=u.createdAt)?void 0:t.toDate)?void 0:r.call(t),updatedAt:null==(a=null==(i=u.updatedAt)?void 0:i.toDate)?void 0:a.call(i),publishedAt:null==(d=null==(l=u.publishedAt)?void 0:l.toDate)?void 0:d.call(l),recordingAvailableFrom:null==(c=null==(n=u.recordingAvailableFrom)?void 0:n.toDate)?void 0:c.call(n)})})}catch(t){throw new Error(`Failed to fetch featured recordings: ${t.message}`)}},getCourseRecordings:async(e,t={})=>{try{const{limit:r=50,status:i="completed",isPublished:a=!0}=t;let l=g(u(S,"recordings"),v("courseId","==",e),v("status","==",i),m("createdAt","desc"));"all"!==a&&(l=g(l,v("isPublished","==",a))),l=g(l,h(r));const d=await p(l);return d.docs.map(e=>{var t,r,i,a,l,d,n,c;const u=e.data();return s(o({id:e.id},u),{createdAt:null==(r=null==(t=u.createdAt)?void 0:t.toDate)?void 0:r.call(t),updatedAt:null==(a=null==(i=u.updatedAt)?void 0:i.toDate)?void 0:a.call(i),publishedAt:null==(d=null==(l=u.publishedAt)?void 0:l.toDate)?void 0:d.call(l),recordingAvailableFrom:null==(c=null==(n=u.recordingAvailableFrom)?void 0:n.toDate)?void 0:c.call(n)})})}catch(r){throw new Error(`Failed to fetch course recordings: ${r.message}`)}},updateRecording:async(e,t)=>{try{if(!e)throw new Error("Recording ID is required");const r=["title","description","meetLink","recordingUrl","thumbnailUrl","duration","fileSize","quality","format","status","recordingStatus","isPublished","isFeatured","visibility","category","tags","language","level","metaTitle","metaDescription","processingStatus","processingProgress","errorMessage","requiresApproval","accessCode","allowedUsers","driveFileId","instructorEmail","participantEmails","attendeeCount","scheduledTime","sessionEndTime","actualStartTime","actualEndTime","recordingAvailableFrom","maxParticipants","enableRecording"],i={};Object.keys(t).forEach(e=>{r.includes(e)&&(i[e]=t[e])});const a=s(o({},i),{updatedAt:n()});if(t.recordingUrl&&!t.driveFileId){const e=$.extractDriveFileId(t.recordingUrl);e&&(a.driveFileId=e,a.recordingStatus="available")}if(t.isPublished&&!t.publishedAt){const t=await $.getRecordingById(e);t&&!t.publishedAt&&(a.publishedAt=n())}const l=P(a);return await b(A(S,"recordings",e),l),{success:!0,recordingId:e,updatedFields:Object.keys(i)}}catch(r){throw new Error(`Failed to update recording: ${r.message}`)}},updateRecordingRating:async(e,t,r)=>{try{const i=await $.getRecordingById(e);if(!i)throw new Error("Recording not found");const a=(i.totalRatings||0)+1,l=((i.averageRating||0)*(a-1)+t)/a,d={totalRatings:a,averageRating:Math.round(10*l)/10,updatedAt:n()};return r&&(d[`ratings.${r}`]={rating:t,ratedAt:n()}),await b(A(S,"recordings",e),d),{success:!0,recordingId:e,averageRating:l,totalRatings:a}}catch(i){throw new Error(`Failed to update recording rating: ${i.message}`)}},publishRecording:async e=>{try{const t={isPublished:!0,publishedAt:n(),updatedAt:n()};return await b(A(S,"recordings",e),t),{success:!0,recordingId:e,publishedAt:new Date}}catch(t){throw new Error(`Failed to publish recording: ${t.message}`)}},unpublishRecording:async e=>{try{const t={isPublished:!1,updatedAt:n()};return await b(A(S,"recordings",e),t),{success:!0,recordingId:e}}catch(t){throw new Error(`Failed to unpublish recording: ${t.message}`)}},deleteRecording:async e=>{try{return await $.unpublishRecording(e)}catch(t){throw new Error(`Failed to delete recording: ${t.message}`)}},hardDeleteRecording:async e=>{try{if(!(await $.getRecordingById(e)))throw new Error("Recording not found");return await F(A(S,"recordings",e)),{success:!0,recordingId:e,deletedAt:new Date}}catch(t){throw new Error(`Failed to hard delete recording: ${t.message}`)}},searchRecordings:async(e,t={})=>{try{const{category:r="all",level:i="all",status:a="completed",minDuration:l=null,maxDuration:d=null,minRating:o=null,sortBy:s="relevance"}=t;let n=await $.getAllRecordings({status:"completed",isPublished:!0,limit:1e3});if(e){const t=e.toLowerCase();n=n.filter(e=>{var r,i,a,l,d;return(null==(r=e.title)?void 0:r.toLowerCase().includes(t))||(null==(i=e.description)?void 0:i.toLowerCase().includes(t))||(null==(a=e.tags)?void 0:a.some(e=>e.toLowerCase().includes(t)))||(null==(l=e.instructorName)?void 0:l.toLowerCase().includes(t))||(null==(d=e.category)?void 0:d.toLowerCase().includes(t))})}switch("all"!==r&&(n=n.filter(e=>e.category===r)),"all"!==i&&(n=n.filter(e=>e.level===i)),null!==l&&(n=n.filter(e=>e.duration>=l)),null!==d&&(n=n.filter(e=>e.duration<=d)),null!==o&&(n=n.filter(e=>e.averageRating>=o)),s){case"newest":n.sort((e,t)=>new Date(t.createdAt)-new Date(e.createdAt));break;case"popular":n.sort((e,t)=>(t.views||0)-(e.views||0));break;case"rating":n.sort((e,t)=>(t.averageRating||0)-(e.averageRating||0));break;case"duration":n.sort((e,t)=>(t.duration||0)-(e.duration||0));break;default:n.sort((e,t)=>e.isFeatured&&!t.isFeatured?-1:!e.isFeatured&&t.isFeatured?1:(t.views||0)-(e.views||0))}return n}catch(r){throw new Error(`Failed to search recordings: ${r.message}`)}},getRecordingStats:async(e=null)=>{try{let t=u(S,"recordings");e&&(t=g(t,v("instructorId","==",e)));const[r,i,a,l,d]=await Promise.all([T(t),T(g(t,v("isPublished","==",!0))),T(g(t,v("recordingStatus","==","available"))),T(g(t,v("status","==","scheduled"))),$.getAllRecordings({limit:1e3,instructorId:e})]);return{total:r.data().count,published:i.data().count,available:a.data().count,scheduled:l.data().count,processing:d.filter(e=>"processing"===e.recordingStatus).length,totalViews:d.reduce((e,t)=>e+(t.views||0),0),totalDuration:d.reduce((e,t)=>e+(t.duration||0),0),averageRating:d.length>0?d.reduce((e,t)=>e+(t.averageRating||0),0)/d.length:0,totalMeetSessions:d.filter(e=>e.meetLink).length,recordedSessions:d.filter(e=>"available"===e.recordingStatus).length,upcomingSessions:d.filter(e=>"scheduled"===e.status).length,statuses:d.reduce((e,t)=>{const r=t.status||"unknown";return e[r]=(e[r]||0)+1,e},{}),recordingStatuses:d.reduce((e,t)=>{const r=t.recordingStatus||"not_started";return e[r]=(e[r]||0)+1,e},{})}}catch(t){throw new Error(`Failed to fetch recording statistics: ${t.message}`)}},getTotalRecordings:async()=>{try{const e=u(S,"recordings"),t=await T(e);return t.data().count}catch(e){return 0}},bulkUpdateRecordings:async(e,t)=>{try{if(!e.length)return{success:!0,updatedCount:0};const r=R(S),i=n();return e.forEach(e=>{const a=A(S,"recordings",e);r.update(a,s(o({},t),{updatedAt:i}))}),await r.commit(),{success:!0,updatedCount:e.length,updatedAt:new Date}}catch(r){throw new Error(`Failed to bulk update recordings: ${r.message}`)}},validateRecordingData:(e,t=!1)=>{const r=[];return t&&void 0===e.title||(e.title&&0!==e.title.trim().length||r.push("Recording title is required"),e.title&&e.title.length>100&&r.push("Recording title must be less than 100 characters")),e.description&&e.description.length>2e3&&r.push("Recording description must be less than 2000 characters"),void 0!==e.duration&&e.duration<0&&r.push("Duration cannot be negative"),void 0!==e.fileSize&&e.fileSize<0&&r.push("File size cannot be negative"),e.tags&&e.tags.length>10&&r.push("Maximum 10 tags allowed"),e.meetLink&&!e.meetLink.includes("meet.google.com")&&r.push("Invalid Google Meet link"),e.recordingUrl&&!$.recordingWorkflow.validateDriveUrl(e.recordingUrl)&&r.push("Invalid Google Drive recording URL"),{isValid:0===r.length,errors:r}},recordingWorkflow:{getRecordingSteps:()=>["1. Create Google Meet session manually","2. Save Meet link in your platform","3. Start session at scheduled time","4. Click 'Record meeting' in Google Meet","5. Teach your session","6. End meeting or stop recording","7. Wait for recording to process (5-60 minutes)","8. Find recording in Google Drive 'Meet Recordings' folder","9. Get shareable link and update in platform"],getShareableLinkSteps:()=>["1. Go to drive.google.com","2. Navigate to 'Meet Recordings' folder","3. Find your recording file","4. Right-click â†’ 'Share'","5. Set permission to 'Anyone with link can view'","6. Copy the shareable link","7. Paste in your platform to update the session"],validateDriveUrl:e=>e&&e.includes("drive.google.com")&&e.includes("/file/d/"),shouldRecordingBeAvailable:e=>{if(!(null==e?void 0:e.actualEndTime))return!1;const t=new Date(e.actualEndTime);return(new Date-t)/6e4>=30}}};export{$ as r};
