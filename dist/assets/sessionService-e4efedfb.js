import{U as e,K as t,P as s,D as a,B as i,H as d,G as o,I as r,A as n,z as c,q as u,M as l,O as m}from"./firebase-383b8577.js";import{d as h}from"./index-fde0d62d.js";const p={createSession:async i=>{try{const d={meetLink:i.meetLink,topic:i.title||i.topic||"Untitled Session",title:i.title||i.topic||"Untitled Session",description:i.description||"",date:e.fromDate(new Date(i.scheduledTime||i.date)),scheduledTime:e.fromDate(new Date(i.scheduledTime||i.date)),duration:i.duration||60,category:i.category||"lecture",visibility:i.visibility||"private",maxParticipants:i.maxParticipants||50,courseId:i.courseId||"general",enableRecording:i.enableRecording??!0,isRecorded:!1,recordingUrl:"",status:"scheduled",recordingStatus:i.enableRecording?"not_started":"disabled",isPublished:"public"===i.visibility,instructorId:i.instructorId||i.createdBy,instructorEmail:i.instructorEmail,instructorName:i.instructorName,createdBy:i.instructorId||i.createdBy,createdAt:t(),updatedAt:t(),sessionEndTime:i.sessionEndTime?e.fromDate(new Date(i.sessionEndTime)):e.fromDate(new Date((i.scheduledTime?new Date(i.scheduledTime).getTime():Date.now())+6e4*(i.duration||60))),participants:[],participantCount:0,participantEmails:i.participantEmails||[],courseName:i.courseName||""};Object.keys(d).forEach(e=>{void 0===d[e]&&delete d[e]});return{success:!0,id:(await s(a(h,"sessions"),d)).id,...d}}catch(d){throw new Error(`Failed to create session: ${d.message}`)}},createSessionRecording:async e=>{try{if(!e.sessionId)throw new Error("sessionId is required for recording");const t={...e,enableRecording:!0,recordingStatus:"not_started"};return await p.createSession(t)}catch(t){throw new Error(`Failed to create session recording: ${t.message}`)}},getAllSessions:async(t={})=>{try{const{limit:s=50,status:c="all",isRecorded:u="all",dateRange:l="all",instructorId:m=null}=t;let p=i(a(h,"sessions"),d("scheduledTime","desc"));"all"!==c&&(p=i(p,o("status","==",c))),"all"!==u&&(p=i(p,o("isRecorded","==","recorded"===u))),m&&(p=i(p,o("instructorId","==",m))),"upcoming"===l?p=i(p,o("scheduledTime",">=",e.now())):"past"===l&&(p=i(p,o("scheduledTime","<",e.now()))),s&&s>0&&(p=i(p,r(s)));const g=await n(p),w=[];return g.forEach(e=>{const t=e.data();w.push({id:e.id,...t,date:t.date?.toDate?.(),scheduledTime:t.scheduledTime?.toDate?.(),sessionEndTime:t.sessionEndTime?.toDate?.(),createdAt:t.createdAt?.toDate?.(),updatedAt:t.updatedAt?.toDate?.()})}),w}catch(s){throw new Error(`Failed to fetch sessions: ${s.message}`)}},getPublicSessions:async(t={})=>{try{const{limit:s=50,status:c="scheduled",dateRange:u="upcoming",instructorId:l=null}=t;let m=i(a(h,"sessions"),o("isPublished","==",!0),o("status","==",c),d("scheduledTime","asc"));"upcoming"===u?m=i(m,o("scheduledTime",">=",e.now())):"past"===u&&(m=i(m,o("scheduledTime","<",e.now()))),l&&(m=i(m,o("instructorId","==",l))),s&&s>0&&(m=i(m,r(s)));const p=await n(m),g=[];return p.forEach(e=>{const t=e.data();g.push({id:e.id,...t,date:t.date?.toDate?.(),scheduledTime:t.scheduledTime?.toDate?.(),sessionEndTime:t.sessionEndTime?.toDate?.(),createdAt:t.createdAt?.toDate?.(),updatedAt:t.updatedAt?.toDate?.()})}),g}catch(s){throw new Error(`Failed to fetch public sessions: ${s.message}`)}},getTeacherSessionsForStudents:async(t={})=>{try{const{limit:s=20,daysAhead:c=30}=t,u=new Date,l=new Date;l.setDate(l.getDate()+c);const m=i(a(h,"sessions"),o("isPublished","==",!0),o("status","==","scheduled"),o("scheduledTime",">=",e.fromDate(u)),o("scheduledTime","<=",e.fromDate(l)),d("scheduledTime","asc"),r(s)),p=await n(m),g=[];return p.forEach(e=>{const t=e.data();g.push({id:e.id,...t,date:t.date?.toDate?.(),scheduledTime:t.scheduledTime?.toDate?.(),sessionEndTime:t.sessionEndTime?.toDate?.(),createdAt:t.createdAt?.toDate?.(),updatedAt:t.updatedAt?.toDate?.()})}),g}catch(s){throw new Error(`Failed to fetch teacher sessions for students: ${s.message}`)}},getCourseSessions:async(e,t={})=>{try{const{limit:s=50}=t;let c=i(a(h,"sessions"),o("courseId","==",e),d("scheduledTime","desc"));s&&s>0&&(c=i(c,r(s)));const u=await n(c),l=[];return u.forEach(e=>{const t=e.data();l.push({id:e.id,...t,date:t.date?.toDate?.(),scheduledTime:t.scheduledTime?.toDate?.(),createdAt:t.createdAt?.toDate?.(),updatedAt:t.updatedAt?.toDate?.()})}),l}catch(s){throw new Error(`Failed to fetch course sessions: ${s.message}`)}},getUpcomingSessions:async(t=20)=>{try{const s=i(a(h,"sessions"),o("scheduledTime",">=",e.now()),o("status","in",["scheduled","live"]),d("scheduledTime","asc"),r(t)),c=await n(s),u=[];return c.forEach(e=>{const t=e.data();u.push({id:e.id,...t,date:t.date?.toDate?.(),scheduledTime:t.scheduledTime?.toDate?.(),createdAt:t.createdAt?.toDate?.(),updatedAt:t.updatedAt?.toDate?.()})}),u}catch(s){throw new Error(`Failed to fetch upcoming sessions: ${s.message}`)}},getInstructorUpcomingSessions:async(t,s={})=>{try{const{limit:c=10,daysAhead:u=7}=s,l=new Date,m=new Date;m.setDate(m.getDate()+u);let p=i(a(h,"sessions"),o("instructorId","==",t),o("scheduledTime",">=",e.fromDate(l)),o("scheduledTime","<=",e.fromDate(m)),o("status","in",["scheduled","live"]),d("scheduledTime","asc"));c&&c>0&&(p=i(p,r(c)));const g=await n(p),w=[];return g.forEach(e=>{const t=e.data();w.push({id:e.id,...t,date:t.date?.toDate?.(),scheduledTime:t.scheduledTime?.toDate?.(),createdAt:t.createdAt?.toDate?.(),updatedAt:t.updatedAt?.toDate?.()})}),w}catch(c){throw new Error(`Failed to fetch instructor upcoming sessions: ${c.message}`)}},getInstructorSessions:async(e,t={})=>{try{const{limit:s=50,status:c="all"}=t;let u=i(a(h,"sessions"),o("instructorId","==",e),d("scheduledTime","desc"));"all"!==c&&(u=i(u,o("status","==",c))),s&&s>0&&(u=i(u,r(s)));const l=await n(u),m=[];return l.forEach(e=>{const t=e.data();m.push({id:e.id,...t,date:t.date?.toDate?.(),scheduledTime:t.scheduledTime?.toDate?.(),createdAt:t.createdAt?.toDate?.(),updatedAt:t.updatedAt?.toDate?.()})}),m}catch(s){throw new Error(`Failed to fetch instructor sessions: ${s.message}`)}},getRecordedSessions:async(e=20)=>{try{const t=i(a(h,"sessions"),o("isRecorded","==",!0),d("scheduledTime","desc"),r(e)),s=await n(t),c=[];return s.forEach(e=>{const t=e.data();c.push({id:e.id,...t,date:t.date?.toDate?.(),scheduledTime:t.scheduledTime?.toDate?.(),createdAt:t.createdAt?.toDate?.(),updatedAt:t.updatedAt?.toDate?.()})}),c}catch(t){throw new Error(`Failed to fetch recorded sessions: ${t.message}`)}},getSessionById:async e=>{try{const t=await c(u(h,"sessions",e));if(!t.exists())return null;const s=t.data();return{id:t.id,...s,date:s.date?.toDate?.(),scheduledTime:s.scheduledTime?.toDate?.(),sessionEndTime:s.sessionEndTime?.toDate?.(),createdAt:s.createdAt?.toDate?.(),updatedAt:s.updatedAt?.toDate?.()}}catch(t){throw new Error(`Failed to fetch session: ${t.message}`)}},updateSession:async(s,a)=>{try{const i=["meetLink","topic","title","description","scheduledTime","date","status","courseId","courseName","duration","category","visibility","maxParticipants","enableRecording","recordingStatus","isPublished","sessionEndTime"],d={};Object.keys(a).forEach(e=>{i.includes(e)&&(d[e]=a[e])});const o={...d,updatedAt:t()};return a.scheduledTime&&a.scheduledTime instanceof Date&&(o.scheduledTime=e.fromDate(a.scheduledTime)),a.date&&a.date instanceof Date&&(o.date=e.fromDate(a.date)),a.sessionEndTime&&a.sessionEndTime instanceof Date&&(o.sessionEndTime=e.fromDate(a.sessionEndTime)),await l(u(h,"sessions",s),o),{success:!0,sessionId:s,updates:d}}catch(i){throw new Error(`Failed to update session: ${i.message}`)}},markAsRecorded:async(e,s)=>{try{const a={isRecorded:!0,recordingUrl:s,recordingStatus:"completed",status:"completed",updatedAt:t()};return await l(u(h,"sessions",e),a),{success:!0,sessionId:e,recordingUrl:s}}catch(a){throw new Error(`Failed to mark session as recorded: ${a.message}`)}},removeRecording:async e=>{try{const s={isRecorded:!1,recordingUrl:"",recordingStatus:"disabled",updatedAt:t()};return await l(u(h,"sessions",e),s),{success:!0,sessionId:e}}catch(s){throw new Error(`Failed to remove recording: ${s.message}`)}},updateSessionStatus:async(e,s)=>{try{const a=["scheduled","live","completed","cancelled"];if(!a.includes(s))throw new Error(`Invalid status: ${s}. Must be one of: ${a.join(", ")}`);return await l(u(h,"sessions",e),{status:s,updatedAt:t()}),{success:!0,sessionId:e,status:s}}catch(a){throw new Error(`Failed to update session status: ${a.message}`)}},addParticipant:async(e,s,a={})=>{try{const i=await p.getSessionById(e);if(!i)throw new Error("Session not found");const d={id:s,joinedAt:t(),...a},o=[...i.participants||[],d],r=[...new Set([...i.participantEmails||[],a.email].filter(Boolean))];return await l(u(h,"sessions",e),{participants:o,participantCount:o.length,participantEmails:r,updatedAt:t()}),{success:!0,sessionId:e,participantId:s,participantCount:o.length}}catch(i){throw new Error(`Failed to add participant: ${i.message}`)}},deleteSession:async e=>{try{const t=await p.getSessionById(e);if(!t)throw new Error("Session not found");return t.isRecorded,await m(u(h,"sessions",e)),{success:!0,sessionId:e,hadRecording:t.isRecorded}}catch(t){throw new Error(`Failed to delete session: ${t.message}`)}},getSessionStats:async(e=null)=>{try{const t=e?{instructorId:e}:{},[s,a,i]=await Promise.all([p.getAllSessions({...t,limit:1e3}),p.getUpcomingSessions(1e3),p.getRecordedSessions(1e3)]),d=e?s.filter(t=>t.instructorId===e):s,o=e?a.filter(t=>t.instructorId===e):a,r=e?i.filter(t=>t.instructorId===e):i;return{total:d.length,upcoming:o.length,recorded:r.length,live:d.filter(e=>"live"===e.status).length,completed:d.filter(e=>"completed"===e.status).length,cancelled:d.filter(e=>"cancelled"===e.status).length,averageParticipants:d.length>0?d.reduce((e,t)=>e+(t.participantCount||0),0)/d.length:0,recentSessions:d.slice(0,5)}}catch(t){throw new Error(`Failed to fetch session statistics: ${t.message}`)}},getInstructorSessionStats:async e=>p.getSessionStats(e)};export{p as s};
