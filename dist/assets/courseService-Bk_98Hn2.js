var e=Object.defineProperty,t=Object.defineProperties,l=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable,a=(t,l,s)=>l in t?e(t,l,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[l]=s,d=(e,t)=>{for(var l in t||(t={}))o.call(t,l)&&a(e,l,t[l]);if(s)for(var l of s(t))r.call(t,l)&&a(e,l,t[l]);return e},n=(e,s)=>t(e,l(s));import{l as u,h as c,A as i,z as m,y as p,G as h,q as v,r as A,w,t as g,p as f,F as y,E as b,v as E}from"./firebase-DbUGxvwD.js";import{d as C}from"./index-DEgoYGZl.js";const D={getPublishedCourses:async(e={})=>{try{const{limit:t=20,category:l="all",level:s="all",instructorId:o=null}=e;let r=v(A(C,"courses"),w("isPublished","==",!0),g("createdAt","desc"));l&&"all"!==l&&(r=v(r,w("category","==",l))),s&&"all"!==s&&(r=v(r,w("level","==",s))),o&&(r=v(r,w("instructorId","==",o))),t&&t>0&&(r=v(r,E(t)));const a=await f(r),u=[];return a.forEach(e=>{var t,l,s,o,r,a;const c=e.data();u.push(n(d({id:e.id},c),{createdAt:null==(l=null==(t=c.createdAt)?void 0:t.toDate)?void 0:l.call(t),updatedAt:null==(o=null==(s=c.updatedAt)?void 0:s.toDate)?void 0:o.call(s),publishedAt:null==(a=null==(r=c.publishedAt)?void 0:r.toDate)?void 0:a.call(r)}))}),u}catch(t){throw new Error(`Failed to fetch published courses: ${t.message}`)}},getAllCourses:async(e={})=>{try{const{limit:t=50,category:l="all",level:s="all",isPublished:o=!0}=e;let r=v(A(C,"courses"),w("isPublished","==",!0),g("createdAt","desc"));"all"!==l&&(r=v(r,w("category","==",l))),"all"!==s&&(r=v(r,w("level","==",s))),t&&t>0&&(r=v(r,E(t)));const a=await f(r),u=[];return a.forEach(e=>{var t,l,s,o,r,a;const c=e.data();u.push(n(d({id:e.id},c),{createdAt:null==(l=null==(t=c.createdAt)?void 0:t.toDate)?void 0:l.call(t),updatedAt:null==(o=null==(s=c.updatedAt)?void 0:s.toDate)?void 0:o.call(s),publishedAt:null==(a=null==(r=c.publishedAt)?void 0:r.toDate)?void 0:a.call(r)}))}),u}catch(t){throw new Error(`Failed to fetch courses: ${t.message}`)}},getEnrolledCourses:async(e,t={})=>{var l,s,o,r,a,i,m,p,h,y;try{if(!e)throw new Error("Student ID is required");const{limit:D=50,status:I="all"}=t;let M;M="all"===I?v(A(C,"enrollments"),w("studentId","==",e),g("enrolledAt","desc")):v(A(C,"enrollments"),w("studentId","==",e),w("status","==",I),g("enrolledAt","desc")),D&&D>0&&(M=v(M,E(D)));const P=await f(M),F=[];for(const e of P.docs){const t=e.data(),v=t.courseId;try{const A=await u(c(C,"courses",v));if(A.exists()){const u=A.data();F.push(n(d({id:A.id},u),{enrollmentId:e.id,enrollmentStatus:t.status,enrolledAt:null==(s=null==(l=t.enrolledAt)?void 0:l.toDate)?void 0:s.call(l),progress:t.progress||0,lastAccessed:null==(r=null==(o=t.lastAccessed)?void 0:o.toDate)?void 0:r.call(o),completedAt:null==(i=null==(a=t.completedAt)?void 0:a.toDate)?void 0:i.call(a),createdAt:null==(p=null==(m=u.createdAt)?void 0:m.toDate)?void 0:p.call(m),updatedAt:null==(y=null==(h=u.updatedAt)?void 0:h.toDate)?void 0:y.call(h)}))}}catch(b){}}return F}catch(b){throw new Error(`Failed to fetch enrolled courses: ${b.message}`)}},getCourseById:async(e,t=null)=>{var l,s,o,r,a,i,m,p,h,g,y,b;try{if(!e)throw new Error("Course ID is required");const D=await u(c(C,"courses",e));if(!D.exists())return null;const I=D.data();if(!I.isPublished)return null;const M=n(d({id:D.id},I),{createdAt:null==(s=null==(l=I.createdAt)?void 0:l.toDate)?void 0:s.call(l),updatedAt:null==(r=null==(o=I.updatedAt)?void 0:o.toDate)?void 0:r.call(o),publishedAt:null==(i=null==(a=I.publishedAt)?void 0:a.toDate)?void 0:i.call(a)});if(t)try{const l=v(A(C,"enrollments"),w("studentId","==",t),w("courseId","==",e)),s=await f(l);if(!s.empty){const e=s.docs[0].data();M.enrollment={id:s.docs[0].id,status:e.status,enrolledAt:null==(p=null==(m=e.enrolledAt)?void 0:m.toDate)?void 0:p.call(m),progress:e.progress||0,lastAccessed:null==(g=null==(h=e.lastAccessed)?void 0:h.toDate)?void 0:g.call(h),completedAt:null==(b=null==(y=e.completedAt)?void 0:y.toDate)?void 0:b.call(y),completedModules:e.completedModules||0,totalModules:e.totalModules||0}}}catch(E){}return M}catch(E){throw new Error(`Failed to fetch course: ${E.message}`)}},enrollInCourse:async(e,t,l={})=>{try{if(!e||!t)throw new Error("Course ID and Student ID are required");const s=await u(c(C,"courses",e));if(!s.exists())throw new Error("Course not found");const o=s.data();if(!o.isPublished)throw new Error("Course is not available for enrollment");const r=v(A(C,"enrollments"),w("studentId","==",t),w("courseId","==",e)),a=await f(r);if(!a.empty){const e=a.docs[0].data();throw new Error(`Already enrolled in this course (Status: ${e.status})`)}const d=v(A(C,"modules"),w("courseId","==",e),w("isPublished","==",!0)),n=(await f(d)).size,p={courseId:e,studentId:t,studentEmail:l.email||"",studentName:l.name||"",status:"active",progress:0,enrolledAt:m(),lastAccessed:m(),completedAt:null,totalModules:n,completedModules:0,updatedAt:m()},h=await y(A(C,"enrollments"),p);return await i(c(C,"courses",e),{enrolledStudents:b(t),totalEnrollments:(o.totalEnrollments||0)+1,updatedAt:m()}),{success:!0,enrollmentId:h.id,course:{id:e,title:o.title,instructorName:o.instructorName,totalModules:n}}}catch(s){throw new Error(`Failed to enroll in course: ${s.message}`)}},updateCourseProgress:async(e,t)=>{try{const l={progress:Math.min(Math.max(t.progress||0,0),100),lastAccessed:m(),updatedAt:m()};return void 0!==t.completedModules&&(l.completedModules=Math.max(0,t.completedModules)),l.progress>=100&&(l.status="completed",l.completedAt=m(),l.progress=100),await i(c(C,"enrollments",e),l),{success:!0,enrollmentId:e,progress:l.progress,status:l.status}}catch(l){throw new Error(`Failed to update course progress: ${l.message}`)}},getCourseModules:async(e,t=null)=>{try{const s=v(A(C,"modules"),w("courseId","==",e),w("isPublished","==",!0),g("order","asc")),o=await f(s),r=[];if(o.forEach(e=>{var t,l,s,o;const a=e.data();r.push(n(d({id:e.id},a),{createdAt:null==(l=null==(t=a.createdAt)?void 0:t.toDate)?void 0:l.call(t),updatedAt:null==(o=null==(s=a.updatedAt)?void 0:s.toDate)?void 0:o.call(s),isCompleted:!1}))}),t)try{const l=v(A(C,"enrollments"),w("studentId","==",t),w("courseId","==",e)),s=await f(l);if(!s.empty){const e=s.docs[0].data().completedModules||[];r.forEach(t=>{t.isCompleted=e.includes(t.id)})}}catch(l){}return r}catch(l){throw new Error(`Failed to fetch course modules: ${l.message}`)}},searchCourses:async(e,t={})=>{try{const l=await D.getAllCourses({limit:1e3});if(!e&&0===Object.keys(t).length)return l.slice(0,50);let s=l;if(e){const t=e.toLowerCase();s=s.filter(e=>{var l,s,o,r;return(null==(l=e.title)?void 0:l.toLowerCase().includes(t))||(null==(s=e.description)?void 0:s.toLowerCase().includes(t))||(null==(o=e.instructorName)?void 0:o.toLowerCase().includes(t))||(null==(r=e.category)?void 0:r.toLowerCase().includes(t))||(e.tags||[]).some(e=>e.toLowerCase().includes(t))})}return t.category&&"all"!==t.category&&(s=s.filter(e=>e.category===t.category)),t.level&&"all"!==t.level&&(s=s.filter(e=>e.level===t.level)),t.difficulty&&"all"!==t.difficulty&&(s=s.filter(e=>e.difficulty===t.difficulty)),t.instructorId&&(s=s.filter(e=>e.instructorId===t.instructorId)),s.slice(0,50)}catch(l){throw new Error(`Failed to search courses: ${l.message}`)}},getFeaturedCourses:async(e=10)=>{try{const t=v(A(C,"courses"),w("isPublished","==",!0),w("isFeatured","==",!0),g("createdAt","desc"),e(e)),l=await f(t),s=[];return l.forEach(e=>{var t,l,o,r,a,u;const c=e.data();s.push(n(d({id:e.id},c),{createdAt:null==(l=null==(t=c.createdAt)?void 0:t.toDate)?void 0:l.call(t),updatedAt:null==(r=null==(o=c.updatedAt)?void 0:o.toDate)?void 0:r.call(o),publishedAt:null==(u=null==(a=c.publishedAt)?void 0:a.toDate)?void 0:u.call(a)}))}),s}catch(t){return D.getPublishedCourses({limit:e})}},getPopularCourses:async(e=10)=>{try{const t=v(A(C,"courses"),w("isPublished","==",!0),g("totalEnrollments","desc"),e(e)),l=await f(t),s=[];return l.forEach(e=>{var t,l,o,r,a,u;const c=e.data();s.push(n(d({id:e.id},c),{createdAt:null==(l=null==(t=c.createdAt)?void 0:t.toDate)?void 0:l.call(t),updatedAt:null==(r=null==(o=c.updatedAt)?void 0:o.toDate)?void 0:r.call(o),publishedAt:null==(u=null==(a=c.publishedAt)?void 0:a.toDate)?void 0:u.call(a)}))}),s}catch(t){return D.getPublishedCourses({limit:e})}},unenrollFromCourse:async(e,t,l)=>{try{await p(c(C,"enrollments",e));const s=await u(c(C,"courses",t));if(s.exists()){const e=s.data();await i(c(C,"courses",t),{enrolledStudents:h(l),totalEnrollments:Math.max((e.totalEnrollments||1)-1,0),updatedAt:m()})}return{success:!0,enrollmentId:e,courseId:t}}catch(s){throw new Error(`Failed to unenroll from course: ${s.message}`)}},getStudentCourseStats:async e=>{try{const[t,l]=await Promise.all([D.getEnrolledCourses(e,{limit:1e3}),D.getPublishedCourses({limit:1e3})]),s=t.filter(e=>"completed"===e.enrollmentStatus),o=t.filter(e=>"active"===e.enrollmentStatus);return{totalEnrolled:t.length,totalAvailable:l.length,completedCourses:s.length,inProgressCourses:o.length,averageProgress:t.length>0?Math.round(t.reduce((e,t)=>e+(t.progress||0),0)/t.length):0,recentEnrollments:t.slice(0,5),totalLearningTime:t.reduce((e,t)=>e+(t.estimatedDuration||0),0)}}catch(t){throw new Error(`Failed to fetch student course stats: ${t.message}`)}},markModuleCompleted:async(e,t,l,s)=>{try{const l=await u(c(C,"enrollments",e));if(!l.exists())throw new Error("Enrollment not found");const s=l.data(),o=s.completedModules||[];if(o.includes(t))return{success:!0,alreadyCompleted:!0};const r=[...o,t],a=s.totalModules||1,n=Math.round(r.length/a*100);return await i(c(C,"enrollments",e),d({completedModules:r,progress:n,lastAccessed:m(),updatedAt:m()},n>=100?{status:"completed",completedAt:m()}:{})),{success:!0,progress:n,completedModules:r.length,totalModules:a,isCourseCompleted:n>=100}}catch(o){throw new Error(`Failed to mark module as completed: ${o.message}`)}}};export{D as c};
