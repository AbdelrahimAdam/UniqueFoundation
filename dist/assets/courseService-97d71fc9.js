var e=Object.defineProperty,t=Object.defineProperties,l=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable,a=(t,l,s)=>l in t?e(t,l,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[l]=s,d=(e,t)=>{for(var l in t||(t={}))o.call(t,l)&&a(e,l,t[l]);if(s)for(var l of s(t))r.call(t,l)&&a(e,l,t[l]);return e},n=(e,s)=>t(e,l(s));import{q as u,r as c,w as i,t as m,v as p,p as h,n as v,h as A,y as w,C as g,z as f,D as y,B as b,G as C}from"./firebase-a4f86f3d.js";import{d as E}from"./index-cde8ec3e.js";const D={getPublishedCourses:async(e={})=>{try{const{limit:t=20,category:l="all",level:s="all",instructorId:o=null}=e;let r=u(c(E,"courses"),i("isPublished","==",!0),m("createdAt","desc"));l&&"all"!==l&&(r=u(r,i("category","==",l))),s&&"all"!==s&&(r=u(r,i("level","==",s))),o&&(r=u(r,i("instructorId","==",o))),t&&t>0&&(r=u(r,p(t)));const a=await h(r),v=[];return a.forEach(e=>{var t,l,s,o,r,a;const u=e.data();v.push(n(d({id:e.id},u),{createdAt:null==(l=null==(t=u.createdAt)?void 0:t.toDate)?void 0:l.call(t),updatedAt:null==(o=null==(s=u.updatedAt)?void 0:s.toDate)?void 0:o.call(s),publishedAt:null==(a=null==(r=u.publishedAt)?void 0:r.toDate)?void 0:a.call(r)}))}),v}catch(t){throw new Error(`Failed to fetch published courses: ${t.message}`)}},getAllCourses:async(e={})=>{try{const{limit:t=50,category:l="all",level:s="all",isPublished:o=!0}=e;let r=u(c(E,"courses"),i("isPublished","==",!0),m("createdAt","desc"));"all"!==l&&(r=u(r,i("category","==",l))),"all"!==s&&(r=u(r,i("level","==",s))),t&&t>0&&(r=u(r,p(t)));const a=await h(r),v=[];return a.forEach(e=>{var t,l,s,o,r,a;const u=e.data();v.push(n(d({id:e.id},u),{createdAt:null==(l=null==(t=u.createdAt)?void 0:t.toDate)?void 0:l.call(t),updatedAt:null==(o=null==(s=u.updatedAt)?void 0:s.toDate)?void 0:o.call(s),publishedAt:null==(a=null==(r=u.publishedAt)?void 0:r.toDate)?void 0:a.call(r)}))}),v}catch(t){throw new Error(`Failed to fetch courses: ${t.message}`)}},getEnrolledCourses:async(e,t={})=>{var l,s,o,r,a,w,g,f,y,b;try{if(!e)throw new Error("Student ID is required");const{limit:D=50,status:I="all"}=t;let M;M="all"===I?u(c(E,"enrollments"),i("studentId","==",e),m("enrolledAt","desc")):u(c(E,"enrollments"),i("studentId","==",e),i("status","==",I),m("enrolledAt","desc")),D&&D>0&&(M=u(M,p(D)));const P=await h(M),F=[];for(const e of P.docs){const t=e.data(),u=t.courseId;try{const c=await v(A(E,"courses",u));if(c.exists()){const u=c.data();F.push(n(d({id:c.id},u),{enrollmentId:e.id,enrollmentStatus:t.status,enrolledAt:null==(s=null==(l=t.enrolledAt)?void 0:l.toDate)?void 0:s.call(l),progress:t.progress||0,lastAccessed:null==(r=null==(o=t.lastAccessed)?void 0:o.toDate)?void 0:r.call(o),completedAt:null==(w=null==(a=t.completedAt)?void 0:a.toDate)?void 0:w.call(a),createdAt:null==(f=null==(g=u.createdAt)?void 0:g.toDate)?void 0:f.call(g),updatedAt:null==(b=null==(y=u.updatedAt)?void 0:y.toDate)?void 0:b.call(y)}))}}catch(C){}}return F}catch(C){throw new Error(`Failed to fetch enrolled courses: ${C.message}`)}},getCourseById:async(e,t=null)=>{var l,s,o,r,a,m,p,w,g,f,y,b;try{if(!e)throw new Error("Course ID is required");const D=await v(A(E,"courses",e));if(!D.exists())return null;const I=D.data();if(!I.isPublished)return null;const M=n(d({id:D.id},I),{createdAt:null==(s=null==(l=I.createdAt)?void 0:l.toDate)?void 0:s.call(l),updatedAt:null==(r=null==(o=I.updatedAt)?void 0:o.toDate)?void 0:r.call(o),publishedAt:null==(m=null==(a=I.publishedAt)?void 0:a.toDate)?void 0:m.call(a)});if(t)try{const l=u(c(E,"enrollments"),i("studentId","==",t),i("courseId","==",e)),s=await h(l);if(!s.empty){const e=s.docs[0].data();M.enrollment={id:s.docs[0].id,status:e.status,enrolledAt:null==(w=null==(p=e.enrolledAt)?void 0:p.toDate)?void 0:w.call(p),progress:e.progress||0,lastAccessed:null==(f=null==(g=e.lastAccessed)?void 0:g.toDate)?void 0:f.call(g),completedAt:null==(b=null==(y=e.completedAt)?void 0:y.toDate)?void 0:b.call(y),completedModules:e.completedModules||0,totalModules:e.totalModules||0}}}catch(C){}return M}catch(C){throw new Error(`Failed to fetch course: ${C.message}`)}},enrollInCourse:async(e,t,l={})=>{try{if(!e||!t)throw new Error("Course ID and Student ID are required");const s=await v(A(E,"courses",e));if(!s.exists())throw new Error("Course not found");const o=s.data();if(!o.isPublished)throw new Error("Course is not available for enrollment");const r=u(c(E,"enrollments"),i("studentId","==",t),i("courseId","==",e)),a=await h(r);if(!a.empty){const e=a.docs[0].data();throw new Error(`Already enrolled in this course (Status: ${e.status})`)}const d=u(c(E,"modules"),i("courseId","==",e),i("isPublished","==",!0)),n=(await h(d)).size,m={courseId:e,studentId:t,studentEmail:l.email||"",studentName:l.name||"",status:"active",progress:0,enrolledAt:w(),lastAccessed:w(),completedAt:null,totalModules:n,completedModules:0,updatedAt:w()},p=await g(c(E,"enrollments"),m);return await f(A(E,"courses",e),{enrolledStudents:y(t),totalEnrollments:(o.totalEnrollments||0)+1,updatedAt:w()}),{success:!0,enrollmentId:p.id,course:{id:e,title:o.title,instructorName:o.instructorName,totalModules:n}}}catch(s){throw new Error(`Failed to enroll in course: ${s.message}`)}},updateCourseProgress:async(e,t)=>{try{const l={progress:Math.min(Math.max(t.progress||0,0),100),lastAccessed:w(),updatedAt:w()};return void 0!==t.completedModules&&(l.completedModules=Math.max(0,t.completedModules)),l.progress>=100&&(l.status="completed",l.completedAt=w(),l.progress=100),await f(A(E,"enrollments",e),l),{success:!0,enrollmentId:e,progress:l.progress,status:l.status}}catch(l){throw new Error(`Failed to update course progress: ${l.message}`)}},getCourseModules:async(e,t=null)=>{try{const s=u(c(E,"modules"),i("courseId","==",e),i("isPublished","==",!0),m("order","asc")),o=await h(s),r=[];if(o.forEach(e=>{var t,l,s,o;const a=e.data();r.push(n(d({id:e.id},a),{createdAt:null==(l=null==(t=a.createdAt)?void 0:t.toDate)?void 0:l.call(t),updatedAt:null==(o=null==(s=a.updatedAt)?void 0:s.toDate)?void 0:o.call(s),isCompleted:!1}))}),t)try{const l=u(c(E,"enrollments"),i("studentId","==",t),i("courseId","==",e)),s=await h(l);if(!s.empty){const e=s.docs[0].data().completedModules||[];r.forEach(t=>{t.isCompleted=e.includes(t.id)})}}catch(l){}return r}catch(l){throw new Error(`Failed to fetch course modules: ${l.message}`)}},searchCourses:async(e,t={})=>{try{const l=await D.getAllCourses({limit:1e3});if(!e&&0===Object.keys(t).length)return l.slice(0,50);let s=l;if(e){const t=e.toLowerCase();s=s.filter(e=>{var l,s,o,r;return(null==(l=e.title)?void 0:l.toLowerCase().includes(t))||(null==(s=e.description)?void 0:s.toLowerCase().includes(t))||(null==(o=e.instructorName)?void 0:o.toLowerCase().includes(t))||(null==(r=e.category)?void 0:r.toLowerCase().includes(t))||(e.tags||[]).some(e=>e.toLowerCase().includes(t))})}return t.category&&"all"!==t.category&&(s=s.filter(e=>e.category===t.category)),t.level&&"all"!==t.level&&(s=s.filter(e=>e.level===t.level)),t.difficulty&&"all"!==t.difficulty&&(s=s.filter(e=>e.difficulty===t.difficulty)),t.instructorId&&(s=s.filter(e=>e.instructorId===t.instructorId)),s.slice(0,50)}catch(l){throw new Error(`Failed to search courses: ${l.message}`)}},getFeaturedCourses:async(e=10)=>{try{const t=u(c(E,"courses"),i("isPublished","==",!0),i("isFeatured","==",!0),m("createdAt","desc"),e(e)),l=await h(t),s=[];return l.forEach(e=>{var t,l,o,r,a,u;const c=e.data();s.push(n(d({id:e.id},c),{createdAt:null==(l=null==(t=c.createdAt)?void 0:t.toDate)?void 0:l.call(t),updatedAt:null==(r=null==(o=c.updatedAt)?void 0:o.toDate)?void 0:r.call(o),publishedAt:null==(u=null==(a=c.publishedAt)?void 0:a.toDate)?void 0:u.call(a)}))}),s}catch(t){return D.getPublishedCourses({limit:e})}},getPopularCourses:async(e=10)=>{try{const t=u(c(E,"courses"),i("isPublished","==",!0),m("totalEnrollments","desc"),e(e)),l=await h(t),s=[];return l.forEach(e=>{var t,l,o,r,a,u;const c=e.data();s.push(n(d({id:e.id},c),{createdAt:null==(l=null==(t=c.createdAt)?void 0:t.toDate)?void 0:l.call(t),updatedAt:null==(r=null==(o=c.updatedAt)?void 0:o.toDate)?void 0:r.call(o),publishedAt:null==(u=null==(a=c.publishedAt)?void 0:a.toDate)?void 0:u.call(a)}))}),s}catch(t){return D.getPublishedCourses({limit:e})}},unenrollFromCourse:async(e,t,l)=>{try{await b(A(E,"enrollments",e));const s=await v(A(E,"courses",t));if(s.exists()){const e=s.data();await f(A(E,"courses",t),{enrolledStudents:C(l),totalEnrollments:Math.max((e.totalEnrollments||1)-1,0),updatedAt:w()})}return{success:!0,enrollmentId:e,courseId:t}}catch(s){throw new Error(`Failed to unenroll from course: ${s.message}`)}},getStudentCourseStats:async e=>{try{const[t,l]=await Promise.all([D.getEnrolledCourses(e,{limit:1e3}),D.getPublishedCourses({limit:1e3})]),s=t.filter(e=>"completed"===e.enrollmentStatus),o=t.filter(e=>"active"===e.enrollmentStatus);return{totalEnrolled:t.length,totalAvailable:l.length,completedCourses:s.length,inProgressCourses:o.length,averageProgress:t.length>0?Math.round(t.reduce((e,t)=>e+(t.progress||0),0)/t.length):0,recentEnrollments:t.slice(0,5),totalLearningTime:t.reduce((e,t)=>e+(t.estimatedDuration||0),0)}}catch(t){throw new Error(`Failed to fetch student course stats: ${t.message}`)}},markModuleCompleted:async(e,t,l,s)=>{try{const l=await v(A(E,"enrollments",e));if(!l.exists())throw new Error("Enrollment not found");const s=l.data(),o=s.completedModules||[];if(o.includes(t))return{success:!0,alreadyCompleted:!0};const r=[...o,t],a=s.totalModules||1,n=Math.round(r.length/a*100);return await f(A(E,"enrollments",e),d({completedModules:r,progress:n,lastAccessed:w(),updatedAt:w()},n>=100?{status:"completed",completedAt:w()}:{})),{success:!0,progress:n,completedModules:r.length,totalModules:a,isCourseCompleted:n>=100}}catch(o){throw new Error(`Failed to mark module as completed: ${o.message}`)}}};export{D as c};
